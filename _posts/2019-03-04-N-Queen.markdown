---
title: "P, NP and NP-Complete"
layout: post
date: 2019-3-04 23:18
image: /assets/images/markdown.jpg
headerImage: false
tag:
- NP-Complete
- Parallel Computing
- algorithms
- problems
category: blog
author: boshengjian
description: An algorithm to solve N Queen problem
---

## The Problem

N queen problem was first published in the German chess magazine Schack in 1948. Considera n×n chessboard on which n queens are to be placed. Let (i, j) and (k, l) denote the respectivepositions of two queens. The queens are said to threaten each other if

- i = k
- j = l
- |i−k|=|j−l|

The n-queens problem is to position the n queens on the chessboard such that no two queens threaten each other. Note that any valid solution will have exactly one queen in every row and exactly one queen inevery column. The complexity of finding a solution is approximately O(n!), which even for smallvalues of n∼20 can be formidably large. 

A valid solution to the problem can be represented by anarray of n numbers,sol[0..n−1], where sol[i] gives the row in which the queen is present in column i. The rows and columns on the chessboard are numbered from 0 to n−1. The back tracking algorithm is used to find a valid solution by recursively finding valid configurations sol[0..i] from sol[0..i−1]. This can be thought of as searching depth-first in a tree of configurations until wereach a valid leaf node,sol[0..n−1]. 

Particularly, back tracking can be implemented as follows:

Consider a sub problem Si where sol[0..i−1] is filled without any conflicts and a queen in the ith column needs to be placed. We try each of the n possibilities for sol[i]. For each possibility, check if the queen placement so far is still valid ( i.e. queen in columni is not threatened by queens in columns{1. . . i−1}). If invalid, reject and move on to the next possibility for sol[i]. If valid, then consider the sub problem Si+1 of placing the queen in (i+ 1)th column given a valid sol[0..i] before moving on to the next possible position in column i. That is, try all possible ways of filling columns{i+ 1. . . n−1} before advancing to the next possibility on column i.  When the array is full and the solution is valid, report the solution.

```cpp 
void backtrack(unsigned int n, 
               std::vector<unsigned int> & cur_soln, 
               std::vector<std::vector<unsigned int>> & all_solns){
    if (cur_soln.size() == n){
        all_solns.push_back(cur_soln);
        return;
    }
    for (unsigned int i=0; i<n; i++){
        if (isValid(cur_soln.size(), cur_soln, i)){
            cur_soln.push_back(i);
            backtrack(n, cur_soln, all_solns);
            cur_soln.pop_back();
        }
    }
}

bool isValid(unsigned int len, std::vector<unsigned int> & cur_soln, unsigned int candidate) {
    for (unsigned int i=0; i<len; i++){
        if (cur_soln[i] == candidate) 
            return false;   // some solution on the same row
        if ( len-i == cur_soln[i]-candidate || len-i == candidate - cur_soln[i]) 
            return false;   // some solution on the diagonal 
    } 
    return true; 
}
```
## Parallel algorithm

Implement the parallel algorithm by writing three functions:

```cpp
void seq_solver(unsigned int n, std::vector<std::vector<unsigned int> >& all_solns)
void nqueen_master( unsigned int n, unsigned int k, std::vector<std::vector<unsigned int>>& all_solns)
void nqueen_worker(unsigned int n, unsigned int k)
```

The logic of the algorithm is as simple as: 

MASTER's job is to find partial solutions (length is k), and dispatch partial solutions to WORKERS, and WORKERS' job is to complete the partial solution and send back solutions to MASTER.

However, MPI is the hardest part.





---

## Contents
- [Definition](#definition)
- [Reduction](#reduction)
- [Relation of P, NP and NPC](#relation-of-p-np-and-npc)
- [Establish of NP-Completeness](#establish-of-np-completeness)

---

## Definition

Among all the problems, the easiest ones are called P problems, which can be solved in polynomial time. [Wikipedia](https://en.wikipedia.org/wiki/P_(complexity)) defines P problems as "all decision problems can be solved by a deterministic Turing machine using a polynomial amount of computation time, or polynomial time".

Famous NP problem: [Travelling Salesman Problem (TSP)](https://en.wikipedia.org/wiki/Travelling_salesman_problem)

![Screenshot](/assets/blogs/P_NP_NPC/TSP.png)
- For each two cities, an integer cost is given to travel from one of the
two cities to the other. The salesperson wants to make a minimum
cost circuit visiting each city exactly once.
- TSP: Given a complete graph G=(V,E), a cost function w:E->N, and an
integer k, is there a cycle C going through each vertex once and only
once, with ∑<sub>e∈C</sub> w(e) ≤ k ?

NP problems are defined as problems whose solution can be verified in polynomial time. NP is the "set of all decision problems for which the instances where the answer is 'yes' have efficiently verifiable proofs.More precisely, these proofs have to be verifiable by deterministic computations that can be performed in polynomial time" [Wikipedia](https://en.wikipedia.org/wiki/NP_(complexity)). 

More harder problems are NP-Hard problems, they're at least as hard as the hardest problems in NP. And NP-Complete problems are defined as problems belonged to both NP and NP-Hard (i.e. A problem Y is NP-hard if X <=<sub>p</sub> Y for all X ∈ NP)

---

## Reduction
 
Reducible is a very important concept here. Given two problems X and Y, reduction from X to Y is showing that we can solve X using the
algorithm that solves Y. In other words, Y is harder to solve than X.

X is reducible to Y can be written as **X <=<sub></sub> Y**

### Polynomial Reduction

- There exists a function f that converts the input of X to inputs of Y in
polynomial time
- X(i) = YES <=> Y(f(i)) = YES 
- X is polynomial reducible to Y can be written as **X <=<sub>p</sub> Y**

![Screenshot](/assets/blogs/P_NP_NPC/reduction.png)

---

## Relation of P, NP and NPC

To sum up, NP problems are problems we don't know if we can solve them in polynomial time, but given a candidate solution, the solution can be verified in polynomial time. Some problems in NP has been proved that they can be solved in polynomial time, so we call those problems P problems since they're easy. However, what about other NP problems? Are they also polynomial solvable? Will one day in the future someone discovered an algorithm to solve all NP problems in polynomial time? Are all NP problems are actually P problems but human being didn't find out? 

To prove NP = P is difficult, so we come up with NP-Complete problems. By definition of reduction, if any NP-Complete problem can be solved in polynomial time, then all NP problems can be solved in polynomial time, so NP = P. But until now no one has proved that.

The difference between NP-Hard and NP-Complete is that for NP-Hard, it's difficult to verify the candidate solution in polynomial time or it cannot be verified in polynomial time, thus NP-Hard includes NP-Complete. These are some problems which in NP-Hard are not NP-Complete, e.g. [Halting Problem](https://en.wikipedia.org/wiki/Halting_problem).

![Screenshot](/assets/blogs/P_NP_NPC/P_np_np-complete_np-hard.svg)

---

## Establish of NP-Completeness

Recipe to establish NP-completeness of problem Y.
- Step 1. Show that Y is in NP.
- Step 2. Choose an NP-complete problem X.
- Step 3. Prove that X <= <sub>p</sub> Y (poly-time reduction).

![Screenshot](/assets/blogs/P_NP_NPC/problems.png)
<center>How NP-C problems are discovered</center>

Here is a [list](https://en.wikipedia.org/wiki/List_of_NP-complete_problems) of NP-Complete problems.



